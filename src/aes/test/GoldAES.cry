module GoldAES where

// This is just Common/GF28.cry copied over
import GF28

// All of the Cryptol definitions included here are snarfed from:
//    Primitive/Symmetric/Cipher/Block/AES/Specification.cry
// in the cryptol-specs repo.   

// type State    = Vec 4 (Vec 4 (W 8))
// type Column   = Vec 4 (W 8)
// type RoundKey = Vec 4 (Vec 4 (W 8))

/**
 * The algorithms for AES block ciphers are performed on a 4x4 array of bytes.
 * [FIPS-197u1] Section 3.4.
 */

// I'm assuming FWIW that GF28 is 8 here. That's how it's defined in GF28.cry.

type State    = [4][4][8]
type RoundKey = [4][4][8]

/**
 * AddRoundKey combines the state with a round key via the
 * bitwise XOR operator
 * [FIPS-197u1] Section 5.1.4
 */
AddRoundKey : RoundKey -> State -> State
AddRoundKey w state = w ^ state

// Compare with:
//
// addRoundKey :: RoundKey -> State -> State
// addRoundKey rk s = generate $ \ i ->
//                    generate $ \ j ->
//                       lkup s (i , j) ^ lkup rk (i , j)             

/**
 * MixColumns multiplies the state columns by a fixed matrix.
 * [FIPS-197u1] Section 5.1.3.
 */
MixColumns : State -> State
MixColumns state = matrixMult m state
    where m = [ [2,3,1,1] >>> i | i : [2] <- [0 .. 3] ]

/**
 * ShiftRows transforms the state by cycling the last three rows.
 * [FIPS-197u1] Section 5.1.2.
 */
ShiftRows : State -> State
ShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]

// shiftrows :: State -> State
// shiftrows v = generate $ \ i ->
//               generate $ \ j ->
//                            (v `index` i) `index` (j FC.- i)


/**
 * SubBytes applies an invertible, non-linear transformation to the state.
 * [FIPS-197u1] Section 5.1.1.
 *
 * It does so by applying the AES S-box independently to each byte in the state.
 */
SubBytes : State -> State
SubBytes state = [ [ SBox b | b <- row ] | row <- state ]
